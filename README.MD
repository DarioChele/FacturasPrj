# Sistema de Ingreso y GestiÃ³n de Facturas

## ğŸ“Œ DescripciÃ³n
Este proyecto implementa una soluciÃ³n web para el **ingreso, gestiÃ³n y consulta de facturas**, incluyendo la administraciÃ³n de clientes, productos y usuarios (vendedores).

La soluciÃ³n fue desarrollada como **prueba tÃ©cnica**, priorizando:
- DiseÃ±o limpio
- Buenas prÃ¡cticas
- Seguridad
- Claridad arquitectÃ³nica
- Facilidad de ejecuciÃ³n local

---

## ğŸ—ï¸ Arquitectura General

La soluciÃ³n estÃ¡ dividida en **dos proyectos independientes**:

- /backend â†’ API REST (.NET)
- /frontend â†’ Web SPA (Angular)

Esta separaciÃ³n permite:
- Desacoplar frontend y backend
- Facilitar escalabilidad
- Mantener responsabilidades claras

---
```plaintext
FacturaPrj/
â”‚
â”œâ”€â”€ Backend/                # Proyecto C#.NET API
â”‚   â”œâ”€â”€ Controllers/        # Controladores REST (Facturas, Clientes, Productos, Usuarios)
â”‚   â”œâ”€â”€ Database/           # Scripts SQL y archivo SQLite
â”‚   â”œâ”€â”€ Models/             # Clases de entidades (Usuario, Factura, Cliente, etc)
â”‚   â”œâ”€â”€ Persistence/        # Acceso y persistencia de datos
â”‚   â”‚   â”œâ”€â”€ Context/        # Configuracion de conexion con SQLite
â”‚   â”‚   â”œâ”€â”€ Logging/        # Registro de logs del sistema
â”‚   â”‚   â””â”€â”€ Repositories/   # Interfaces y Acceso a datos (ADO.NET con SQLite)
â”‚   â”œâ”€â”€ Services/           # LÃ³gica de negocio
â”‚   â”œâ”€â”€ â””â”€â”€ Interfaces/     # Interfaces para la capa de negocio
â”‚   â””â”€â”€ Program.cs          # ConfiguraciÃ³n principal del API
â”‚
â”œâ”€â”€ Frontend/               # Proyecto Angular
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/     # Componentes del sitio
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ clientes/   # MÃ³dulo CRUD clientes
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ facturas/   # MÃ³dulo CRUD facturas + filtros
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ login/   	# MÃ³dulo de Login
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ productos/  # MÃ³dulo CRUD productos
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ usuarios/   # MÃ³dulo CRUD vendedores
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ shared/     # Componentes y servicios comunes
â”‚   â”‚   â”‚   â”œâ”€â”€ guards/     	# Control de acceso segÃºn rol
â”‚   â”‚   â”‚   â”œâ”€â”€ interceptors/   # AÃ±adir el token JWT en cada peticiÃ³n
â”‚   â”‚   â”‚   â”œâ”€â”€ models/   	# Clases de entidades
â”‚   â”‚   â”‚   â”œâ”€â”€ services/	# Llamadas HTTP al backend y lÃ³gica de negocio del frontend
â”‚   â”‚   â””â”€â”€ environments/       # Variables segÃºn entorno
â”‚   â””â”€â”€ angular.json
â”‚
â”œâ”€â”€ Docs/                   # DocumentaciÃ³n
â”‚   â””â”€â”€ MER.pdf             # Modelo entidad-relaciÃ³n
â”‚
â”œâ”€â”€ README.md               # GuÃ­a rÃ¡pida del proyecto
â”‚
â””â”€â”€ .git/                   # Repositorio Git
```

## ğŸ”§ Backend

### ğŸ“š Stack TecnolÃ³gico
- **.NET 6+** â€“ API REST
- **SQLite** â€“ Base de datos relacional ligera
- **ADO.NET** â€“ Acceso a datos
- **JWT (JSON Web Token)** â€“ AutenticaciÃ³n
- **BCrypt** â€“ EncriptaciÃ³n de contraseÃ±as

> âš ï¸ **Nota importante**:  
> No se utiliza Entity Framework porque me gusta el control directo del acceso a datos y consultas SQL parametrizadas.

---

### ğŸ§± Estructura del Backend
```plaintext
â”œâ”€â”€ Backend/                # Proyecto C#.NET API
â”‚   â”œâ”€â”€ Controllers/        # Controladores REST (Facturas, Clientes, Productos, Usuarios)
â”‚   â”œâ”€â”€ Database/           # Scripts SQL y archivo SQLite
â”‚   â”œâ”€â”€ Models/             # Clases de entidades (Usuario, Factura, Cliente, etc)
â”‚   â”œâ”€â”€ Persistence/        # Acceso y persistencia de datos
â”‚   â”‚   â”œâ”€â”€ Context/        # Configuracion de conexion con SQLite
â”‚   â”‚   â”œâ”€â”€ Logging/        # Registro de logs del sistema
â”‚   â”‚   â””â”€â”€ Repositories/   # Interfaces y Acceso a datos (ADO.NET con SQLite)
â”‚   â”œâ”€â”€ Services/           # LÃ³gica de negocio
â”‚   â”œâ”€â”€ â””â”€â”€ Interfaces/     # Interfaces para la capa de negocio
â”‚   â””â”€â”€ Program.cs          # ConfiguraciÃ³n principal del API
```

Este diseÃ±o busca:
- SeparaciÃ³n de responsabilidades
- CÃ³digo mantenible
- Facilidad de pruebas
- Claridad para equipos tÃ©cnicos

---

### ğŸ” Seguridad

La API implementa mecanismos bÃ¡sicos de seguridad:

- AutenticaciÃ³n mediante **JWT**
- EncriptaciÃ³n de contraseÃ±as con **BCrypt**
- Uso exclusivo de **consultas SQL parametrizadas** para evitar SQL Injection
- SeparaciÃ³n entre entidades y DTOs para no exponer el modelo interno

---

### ğŸ—„ï¸ Modelo de Datos (Resumen)

Entidades principales:

- **Clientes**
- **Usuarios (Vendedores)**
- **Productos**
- **Facturas**
- **DetalleFactura**
- **FormasPago**

Relaciones:
- Cliente 1â€”N Facturas
- Usuario 1â€”N Facturas
- Factura 1â€”N DetalleFactura
- Producto 1â€”N DetalleFactura
- Factura 1â€”N FormasPagoFactura
- FormasPago 1â€”N FormasPagoFactura

--> Las fechas se manejan en formato **ISO-8601** (`yyyy-MM-dd`) para interoperabilidad.

## ğŸ“Š Mini MER (Modelo Entidad-RelaciÃ³n)

```mermaid
erDiagram
    Clientes {
        INTEGER Id PK
        TEXT Identificacion
        TEXT Nombre
        TEXT Telefono
        TEXT Correo
        INTEGER Estado
    }

    Usuarios {
        INTEGER Id PK
        TEXT Nombre
        TEXT PasswordHash
        INTEGER Rol
        INTEGER Estado
    }

    Productos {
        INTEGER Id PK
        TEXT Nombre
        REAL PrecioUnitario
        INTEGER Estado
    }

    FormasPago {
        INTEGER Id PK
        TEXT TipoPago
    }
    FormasPagoFactura {
        INTEGER Id PK
        INTEGER FacturaId 
        INTEGER FormaPagoId 
        REAL ValorPagado
    }
    Facturas {
        INTEGER Id PK
        TEXT NumeroFactura
        INTEGER ClienteId 
        INTEGER UsuarioId 
        TEXT Fecha
        REAL MontoTotal
        INTEGER EstadoPago
        INTEGER EstadoFactura
    }

    DetallesFactura {
        INTEGER Id PK
        INTEGER FacturaId 
        INTEGER ProductoId 
        INTEGER Cantidad
        REAL PrecioUnitario
        REAL PrecioTotal
    }
    

    Clientes ||--o{ Facturas : "tiene"
    Usuarios ||--o{ Facturas : "registra"
    Productos ||--o{ DetallesFactura : "incluye"
    Facturas ||--o{ DetallesFactura : "contiene"    
    Facturas ||--o{ FormasPagoFactura : "paga"
    FormasPago ||--o{ FormasPagoFactura : "utilizado"

```


---

## ğŸŒ Frontend

### ğŸ“š Stack TecnolÃ³gico
- **Angular 17+**
- **Angular Material**

### ğŸ¯ Enfoque
El frontend es una **Single Page Application (SPA)** con un diseÃ±o:
- Simple
- Claro
- No sobrecargado
- Funcional (no â€œfancyâ€, pero tampoco monocromÃ¡tico)

Funcionalidades principales:
- CRUD de clientes
- CRUD de productos
- CRUD bÃ¡sico de usuarios
- CreaciÃ³n y consulta de facturas
- Filtros por nÃºmero, fecha y monto

---

## âš™ï¸ Funcionalidades Implementadas

- AutenticaciÃ³n de usuarios
- CreaciÃ³n de facturas con:
  - Cliente
  - Vendedor
  - Fecha
  - Detalle de productos
  - MÃºltiples formas de pago
- Consulta y visualizaciÃ³n de facturas
- ImpresiÃ³n de facturas
- BÃºsqueda y filtrado
- Persistencia en SQLite

---

## ğŸ§  Decisiones TÃ©cnicas Relevantes

- **SQLite**: elegido para simplificar la ejecuciÃ³n local sin sacrificar integridad relacional.
- **ADO.NET**: uso explÃ­cito de SQL para mayor control y seguridad.
- **JWT**: autenticaciÃ³n stateless ideal para SPA.
- **No ediciÃ³n de facturas**: por buenas prÃ¡cticas contables; una vez emitida, una factura no deberÃ­a modificarse directamente.

---

## ğŸš€ CÃ³mo ejecutar el proyecto

### Backend
```bash
dotnet restore
dotnet run
```
La API quedarÃ¡ disponible en:
```bash
https://localhost:5001
```
Dependencias en caso de que no las pueda resintalar:
  JwtBearer
```bash
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 8.0.0
```
  BCrypt.Net
```bash
dotnet add package BCrypt.Net-Next
```

Frontend
```bash
npm install
ng serve
```
## ğŸ”® Mejoras Futuras

- Tests unitarios robustos
- Manejo de roles y permisos
- PaginaciÃ³n avanzada
- AuditorÃ­a de operaciones
- Despliegue automatizado
- Observabilidad (logs y mÃ©tricas)

## ğŸ§¾ Notas Finales

Este proyecto prioriza:
- Claridad sobre complejidad
- Seguridad sobre velocidad
- DiseÃ±o sostenible sobre soluciones rÃ¡pidas

EstÃ¡ pensado para ser extendido fÃ¡cilmente por un equipo de desarrollo o por quin le ponga ganas ğŸ’ªğŸ˜µğŸš€ğŸ˜‚.

> Si algo falla, no es un bugâ€¦ es una feature en potencia ğŸš€.**
